# name: Production Deployment

# on:
#   push:
#     branches: [main]
#     paths:
#       - 'api/**'
#       - 'web/**'
#       - 'mobile/**'
#       - 'docker-compose.yml'
#   workflow_dispatch:

# jobs:
#   validate:
#     name: Validate Code
#     runs-on: ubuntu-latest
    
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Setup Node.js
#         uses: actions/setup-node@v3
#         with:
#           node-version: '18'

#       - name: Install API dependencies
#         run: cd api && npm ci

#       - name: Lint API
#         run: cd api && npm run lint
#         continue-on-error: true

#       - name: Install Web dependencies
#         run: cd web && npm ci

#       - name: Lint Web
#         run: cd web && npm run lint
#         continue-on-error: true

#       - name: Build Web
#         run: cd web && npm run build:prod

#   security:
#     name: Security Checks
#     runs-on: ubuntu-latest
    
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Run Trivy vulnerability scanner
#         uses: aquasecurity/trivy-action@master
#         with:
#           scan-type: 'fs'
#           scan-ref: '.'
#           format: 'sarif'
#           output: 'trivy-results.sarif'
#         continue-on-error: true

#       - name: Upload Trivy results to GitHub Security tab
#         uses: github/codeql-action/upload-sarif@v2
#         with:
#           sarif_file: 'trivy-results.sarif'
#         continue-on-error: true

#   deploy:
#     name: Deploy to Production
#     needs: [validate, security]
#     runs-on: ubuntu-latest
#     environment:
#       name: production
    
#     if: success()

#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v2

#       - name: Login to Docker Registry
#         uses: docker/login-action@v2
#         with:
#           registry: ${{ secrets.DOCKER_REGISTRY }}
#           username: ${{ secrets.DOCKER_USERNAME }}
#           password: ${{ secrets.DOCKER_PASSWORD }}
#         continue-on-error: true

#       - name: Build and push API image
#         uses: docker/build-push-action@v4
#         with:
#           context: api
#           file: api/Dockerfile
#           push: true
#           tags: |
#             ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:${{ github.sha }}
#             ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:latest
#             ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:prod

#       - name: Build and push Web image
#         uses: docker/build-push-action@v4
#         with:
#           context: web
#           file: web/Dockerfile
#           push: true
#           tags: |
#             ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:${{ github.sha }}
#             ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:latest
#             ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:prod

#       - name: Deploy to production
#         run: |
#           mkdir -p ~/.ssh
#           echo "${{ secrets.PROD_DEPLOY_KEY }}" > ~/.ssh/id_rsa
#           chmod 600 ~/.ssh/id_rsa
#           ssh-keyscan -H ${{ secrets.PROD_DEPLOY_HOST }} >> ~/.ssh/known_hosts
          
#           ssh ${{ secrets.PROD_DEPLOY_USER }}@${{ secrets.PROD_DEPLOY_HOST }} << 'EOF'
#           set -e
          
#           cd ${{ secrets.PROD_DEPLOY_PATH }}
          
#           # Backup current deployment
#           docker-compose -f docker-compose.yml -f docker-compose.prod.yml exec -T postgres pg_dump -U postgres exitsaas > backup_$(date +%Y%m%d_%H%M%S).sql
          
#           # Pull latest code
#           git pull origin main
          
#           # Update .env from secrets
#           cp .env.production .env
          
#           # Pull new images
#           docker-compose -f docker-compose.yml -f docker-compose.prod.yml pull
          
#           # Perform blue-green deployment
#           docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --no-deps api web nginx
          
#           # Wait for services to be healthy
#           sleep 10
          
#           # Run migrations
#           docker-compose exec -T api npm run migrate
          
#           # Health check
#           for i in {1..30}; do
#             if curl -f http://localhost/health; then
#               echo "Health check passed!"
#               break
#             fi
#             echo "Waiting for services to be healthy... ($i/30)"
#             sleep 2
#           done
          
#           echo "Production deployment completed!"
#           EOF
#         env:
#           PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
#           PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
#           PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}

#       - name: Create Release
#         uses: actions/create-release@v1
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         with:
#           tag_name: v${{ github.run_number }}
#           release_name: Release v${{ github.run_number }}
#           body: |
#             Production deployment of commit ${{ github.sha }}
            
#             **Images:**
#             - API: ${{ secrets.DOCKER_REGISTRY }}/exitsaas-api:${{ github.sha }}
#             - Web: ${{ secrets.DOCKER_REGISTRY }}/exitsaas-web:${{ github.sha }}
#           draft: false
#           prerelease: false

#       - name: Send Slack notification
#         uses: 8398a7/action-slack@v3
#         if: always()
#         with:
#           status: ${{ job.status }}
#           text: 'Production Deployment - ${{ job.status }}'
#           webhook_url: ${{ secrets.SLACK_WEBHOOK }}
#           fields: repo,message,commit,author,action,eventName,ref,workflow
#         continue-on-error: true

#       - name: Alert if deployment failed
#         if: failure()
#         uses: 8398a7/action-slack@v3
#         with:
#           status: 'failure'
#           text: 'ðŸš¨ Production Deployment FAILED!'
#           webhook_url: ${{ secrets.SLACK_WEBHOOK }}
#           fields: repo,message,commit,author
